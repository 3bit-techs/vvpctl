#!/usr/bin/env python
# -*- coding: utf-8 -*-

import requests
import logging
import json
import os
import glob
import time
import subprocess
import sys

from timeit import default_timer as timer
from deepdiff import DeepDiff
from argparse import ArgumentParser

def findDeploymentTarget(arguments):
    ''' Find the default deployment target on the list of all deployment targets, and if found return it's id, otherwise create one and return it's id '''

    try:

        # recovering the deployment target
        getDeploymentTargetsRequest = requests.get(
            "%s/api/v1/namespaces/%s/deployment-targets" % (arguments.server, arguments.namespace), headers={"accept": "application/json", "content-type": "application/json"})

        # error check
        getDeploymentTargetsRequest.raise_for_status()

        # search the deployment target on the server list
        deploymentTarget = next((sub for sub in getDeploymentTargetsRequest.json()[
                                'items'] if sub['metadata']['name'] == arguments.deployment_target), None)

        # checking if the default deployment target exists
        if deploymentTarget == None:

            # create and retrieve
            deploymentTarget = createDeploymentTarget(arguments)

        else:

            logging.info("Found deployment target %s with id %s" %
                        (arguments.deployment_target, deploymentTarget['metadata']['id']))

        return deploymentTarget

    except Exception as e:
        logging.exception("An error occurred trying to find the deployment target %s on the server %s " % (arguments.deployment_target, e))
        raise e

def createDeploymentTarget(arguments):
    '''Create a default deployment target to be used by the app'''

    try:

        # request
        default = {
            "apiVersion": "v1",
            "kind": "DeploymentTarget",
            "metadata": {
                "name": arguments.deployment_target,
                "namespace": arguments.namespace
            },
            "spec": {
                "kubernetes": {
                    "namespace": arguments.deployment_target
                }
            }
        }

        logging.info("Couldn't find the default deployment target %s on the server : Creating (dry_run = %s)" %
                        (arguments.deployment_target, str(arguments.dry_run)))

        # creating
        if not arguments.dry_run:

            result = requests.post(
                "%s/api/v1/namespaces/%s/deployment-targets" % (arguments.server, arguments.namespace), json=default, headers={"accept": "application/json", "content-type": "application/json"})

            # error check
            result.raise_for_status()

            return result.json()

    except Exception as e:
        logging.exception("An error occurred trying to create a deployment target on the server %s " % e)
        raise e

def listDeployments(arguments):
    ''' List the list of all installed deployments'''

    try:

        # recovering vvp deployments
        getDeploymentsRequest = requests.get("%s/api/v1/namespaces/%s/deployments" % (arguments.server, arguments.namespace),
                                            headers={"accept": "application/json", "content-type": "application/json"})

        # error check
        getDeploymentsRequest.raise_for_status()

        # get deployments
        return getDeploymentsRequest.json()

    except Exception as e:
        logging.exception("An error occurred trying to list all deployments from server %s " % e)
        raise e

def findDeployment(arguments, deploymentConfig):
    '''Find a deployment'''

    # retrieve the list of installed deployments
    deploymentsList = listDeployments(arguments)

    # search the deployment on the running deployments
    return next((sub for sub in deploymentsList['items'] if sub['metadata']['name'] == deploymentConfig['metadata']['name']), None)

def readDeploymentConfig(arguments):
    '''Read the deployment config file from disk and parse the JSON'''

    try:

        # open the deployment file
        with open(arguments.file, 'r', encoding='utf-8') as deploymentConfigFile:

            # parse the deployment from the file contents
            return json.load(deploymentConfigFile)

    except Exception as e:
        logging.exception("An error occurred when trying to read the deployment config file %s" % e)
        raise e

def delete(arguments, deploymentConfig):
    '''Deletes a deployment'''

    logging.info("Deleting deployment %s : dry_run = %s" % (deploymentConfig['metadata']['name'], str(arguments.dry_run)))

    try:

        if not arguments.dry_run:

            # delete
            result = requests.delete("%s/api/v1/namespaces/%s/deployments/%s" % (
                arguments.server, arguments.namespace, deploymentConfig['metadata']['id']), headers={"accept": "application/json", "content-type": "application/json"})

            # error check
            result.raise_for_status()

    except Exception as e:
        logging.exception("An error occurred trying to delete the deployment %s target from the server %s " % (deploymentConfig['metadata']['name'], e))
        raise e

def waitDeploymentForDesiredState(arguments, deploymentConfig):
    '''Waits a deployment to transition to its desired state'''

    # measuring time for timeout
    start = timer()

    # done flag
    done = False

    # wait for transition
    while not done:

        # retrieve the deployment from the server
        deployment = findDeployment(arguments, deploymentConfig)

        # elapsed time
        elapsed = timer() - start

        # check for timeout
        if elapsed > arguments.timeout:
            raise Exception("Timeout occured (%d seconds) while waiting for the transition of deployment %s to desired state: %s, current state: %s" % (elapsed, deployment['metadata']['name'], deployment['spec']['state'], deployment['status']['state']))

        # checking if the deployment transition has failed,
        # at this point a manual intervention is necessary - for example cancelling the Deployment
        if deployment['status']['state'] == 'FAILED':

            logging.info("Deployment %s transition FAILED (Desired state: %s, Current state: %s) : Cancelling" % (
                deployment['metadata']['name'], deployment['spec']['state'], deployment['status']['state']))

            # cancel before continue
            cancel(arguments, deployment)

        elif deployment['status']['state'] != deployment['spec']['state']:
            logging.info("Deployment %s found on the server (Desired state: %s, Current state: %s) : Waiting for the states %s" % (
                deployment['metadata']['name'], deployment['spec']['state'], deployment['status']['state'], str(desiredStates)))

            logging.info("Waiting for deployment %s transition (Desired state: %s, Current state: %s)" % (
                deployment['metadata']['name'], deployment['spec']['state'], deployment['status']['state']))

            # wait a little bit
            time.sleep(10)

        else:

            # transition finished
            done = True

def upload(arguments):
    '''Uploads a file to the Ververica Artifact Storage'''

    try:

        # get the file size
        fileSize = os.stat(arguments.upload).st_size

        # sanity check
        if fileSize > 50000000:
            raise Exception("Exceeded maximum file lengh in bytes to upload (%d > 50000000)" % fileSize)

        logging.info("Trying to upload artifact: %s (%d bytes)" % (arguments.upload, fileSize))

        with open(arguments.upload, 'rb') as file:

            # post multipart upload
            result = requests.post("%s/artifacts/v1/namespaces/default/artifacts:upload" % arguments.server, files={'file': file})

            # error checking
            result.raise_for_status()

            logging.info("Successfully uploaded artifact:\n%s" % result.text)

            # return the artifact info
            return result.json()

    except Exception as e:
        logging.exception("An error occurred when trying to upload the file to the artifact storage %s" % e)
        raise e

def update(arguments, deploymentConfig, deployment):
    '''Update a deployment'''

    try:
        logging.info("Looking for changes on deployment %s (Desired state: %s, Current state: %s)" % (
                    deployment['metadata']['name'], deployment['spec']['state'], deployment['status']['state']))

        # difference between current and server
        diff = DeepDiff(deployment, deploymentConfig, exclude_paths={"root['status']", "root['metadata']['id']", "root['metadata']['createdAt']", "root['metadata']['modifiedAt']", "root['metadata']['resourceVersion']", "root['metadata']['annotations']['com.dataartisans.appmanager.controller.deployment.transitioning']", "root['metadata']['annotations']['com.dataartisans.appmanager.controller.deployment.spec.version']", "root['metadata']['annotations']['com.dataartisans.appmanager.controller.deployment.transitioning.since']"})

        # changes found
        if bool(diff):
            logging.info("Deployment %s has the following changes %s : Updating (dry_run = %s)" % (deployment['metadata']['name'], str(diff.to_dict()), str(arguments.dry_run)))

            if not arguments.dry_run:
                # patch
                result = requests.patch("%s/api/v1/namespaces/%s/deployments/%s" % (
                    arguments.server, arguments.namespace, deployment['metadata']['id']), headers={"accept": "application/json", "content-type": "application/json"}, json=deploymentConfig)

                # error check
                result.raise_for_status()
        else:
            logging.info("Deployment %s has no changes : Ignoring" % deployment['metadata']['name'])

    except Exception as e:
        logging.exception("An error occurred trying to update the deployment %s target on the server %s " % (deploymentConfig['metadata']['name'], e))
        raise e

def create(arguments, deploymentConfig):
    '''Create a deployment'''

    try:

        # creating deployment
        logging.info("Creating deployment %s : dry_run = %s" % (deploymentConfig['metadata']['name'], str(arguments.dry_run)))

        # dry run
        if not arguments.dry_run:

            # post
            result = requests.post(
                "%s/api/v1/namespaces/%s/deployments" % (arguments.server, arguments.namespace), headers={"accept": "application/json", "content-type": "application/json"}, json=deploymentConfig)

            # error check
            result.raise_for_status()

    except Exception as e:
        logging.exception("An error occurred trying to create the deployment %s target on the server %s " % (deploymentConfig['metadata']['name'], e))
        raise e

def cancel(arguments, deploymentConfig):
    '''Cancel a deployment'''

    try:

        logging.info("Cancelling deployment %s (Desired state: %s, Current state: %s) : dry_run = %s" % (
                    deploymentConfig['metadata']['name'], deploymentConfig['spec']['state'], deploymentConfig['status']['state'], str(arguments.dry_run)))

        # cancelling
        deploymentConfig['spec']['status'] = 'CANCELLED'

        # dry run
        if not arguments.dry_run:

            # patch
            result = requests.patch("%s/api/v1/namespaces/%s/deployments/%s" % (
                arguments.server, arguments.namespace, deploymentConfig['metadata']['id']), headers={"accept": "application/json", "content-type": "application/json"}, json=deploymentConfig)

            # error check
            result.raise_for_status()

    except Exception as e:
        logging.exception("An error occurred trying to cancel the deployment %s target on the server %s " % (deploymentConfig['metadata']['name'], e))
        raise e

def deleteCommand(arguments):
    '''Deletes a deployment'''

    try:

        # retrieve the deployment config
        deploymentConfig = readDeploymentConfig(arguments)

        # search the deployment on the running deployments
        deployment = findDeployment(arguments, deploymentConfig)

        # deployment found on the server
        if deployment != None:

            # wait for transition
            waitDeploymentForDesiredState(arguments, deployment)

            # cancel
            cancel(arguments, deployment)

            # wait for transition
            waitDeploymentForDesiredState(arguments, deployment)

            # delete
            delete(arguments, deployment)

        else:
            logging.info("Deployment %s not found on the server : Ignoring" % deploymentConfig['metadata']['name'])

    except Exception as e:
        logging.exception("An error occurred trying to delete the deployment %s: %s" % (deploymentConfig['metadata']['name'], e))
        # error
        sys.exit(1)

def applyCommand(arguments):
    '''Apply the configuration on a deployment'''

    try:
        # retrieve the deployment config
        deploymentConfig = readDeploymentConfig(arguments)

        # retrieve the deployment target
        deploymentTarget = findDeploymentTarget(arguments)

        # setting deployment target id if not specified
        if 'deploymentTargetId' not in deploymentConfig['spec']:
            deploymentConfig['spec']['deploymentTargetId'] = deploymentTarget['metadata']['id']

        # search the deployment on the running deployments
        deployment = findDeployment(arguments, deploymentConfig)

        # uploads a file to artifact storage
        if arguments.upload != None:

            # upload
            artifact = upload(arguments)

            # only upload
            if not arguments.apply:
                return

            # set the artifact
            deploymentConfig['spec']['template']['spec']['artifact']['jarUri'] = artifact['artifact']['uri']

        # deployment found on the server
        if deployment != None:

            # wait for transition (if any)
            waitDeploymentForDesiredState(arguments, deployment)

            # update the deployment
            update(arguments, deploymentConfig, deployment)

            # wait for running
            waitDeploymentForDesiredState(arguments, deployment)

        # deployment not found on the server
        else:

            # create the deployment
            create(arguments, deploymentConfig)

            # wait for running
            waitDeploymentForDesiredState(arguments, deployment)

    except Exception as e:
        logging.exception("An error occurred trying to update the deployment: %s" % e)
        # error
        sys.exit(1)

if __name__ == "__main__":
    """main

    The application main method.
    """

    # logging
    logging.basicConfig(
        format="%(asctime)s - %(module)s - %(levelname)s - %(message)s",
        level=logging.INFO,
        datefmt="%m/%d/%Y %I:%M:%S %p",
    )

    # parsing arguments
    parser = ArgumentParser(prog="vvpctl", description="Ververica Platform Cli, used to interact with the Application Manager API")
    parser.add_argument("-f", "--file", help="The deployment file", type=str, required=True)
    parser.add_argument("-s", "--server", help="The ververica platform server address. E.g: http://localhost:8080", type=str, required=True)
    parser.add_argument("-n", "--namespace", help="The ververica platform namespace. Note: This feature is only available in Ververica Platform Stream Edition and above", default="default", type=str)
    parser.add_argument("-t", "--deployment-target", help="The Deployment target, which corresponds to different Kubernetes namespaces in the same Kubernetes cluster. If the deployment target doesn't exists the cli will attempt to create one", default="vvp-jobs", type=str)
    parser.add_argument("-a", "--apply", help="Apply a configuration to a deployment", action="store_true")
    parser.add_argument("-d", "--delete", help="Delete a deployment", action="store_true")
    parser.add_argument("-u", "--upload", help="Uploads a file to Ververica Platform Artifact Storage (maximum of 50mb), if used in conjunction with apply, the cli will update the deployment with the uploaded file location", type=str)
    parser.add_argument("--timeout", help="The length of time in seconds to wait before giving up on waiting", type=int, default=600)
    parser.add_argument("--dry-run", help="Only simulate actions without submit the request", action="store_true")

    arguments = parser.parse_args()

    if arguments.apply or arguments.upload:
        applyCommand(arguments)

    elif arguments.delete:
        deleteCommand(arguments)

    else:
        # print help
        parser.print_help()